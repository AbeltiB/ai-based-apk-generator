"""
Pydantic models for AI service data structures.

Defines all input/output schemas for:
- AI requests and responses
- Architecture designs
- Layout definitions
- Blockly block definitions
- Progress updates and errors
"""
from typing import List, Dict, Any, Optional, Literal
from pydantic import BaseModel, Field, field_validator
from datetime import datetime, timezone
from uuid import uuid4


# ============================================================================
# INPUT SCHEMAS (What we receive from API Gateway via RabbitMQ)
# ============================================================================

class PromptContext(BaseModel):
    """
    Optional context information for prompt processing.
    
    Used for multi-turn conversations and extending existing apps.
    """
    existing_components: Optional[List[Dict[str, Any]]] = None
    """Previously generated components (for extensions)"""
    
    conversation_history: Optional[List[Dict[str, Any]]] = None
    """Previous conversation messages"""
    
    project_metadata: Optional[Dict[str, Any]] = None
    """Additional project information"""


class AIRequest(BaseModel):
    """
    AI request message received from RabbitMQ.
    
    This is the primary input to our AI service.
    """
    task_id: str = Field(default_factory=lambda: str(uuid4()))
    """Unique identifier for this request"""
    
    user_id: str
    """User who made the request"""
    
    session_id: str
    """Session identifier"""
    
    socket_id: str
    """WebSocket connection ID for sending responses"""
    
    prompt: str = Field(..., min_length=10, max_length=2000)
    """User's natural language prompt"""
    
    context: Optional[PromptContext] = None
    """Optional context for the request"""
    
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    """When the request was created"""
    
    @field_validator('prompt')
    @classmethod
    def validate_prompt(cls, v: str) -> str:
        """Ensure prompt is not just whitespace"""
        if not v.strip():
            raise ValueError("Prompt cannot be empty or whitespace")
        return v.strip()
    
    class Config:
        json_schema_extra = {
            "example": {
                "task_id": "550e8400-e29b-41d4-a716-446655440000",
                "user_id": "user_123",
                "session_id": "session_abc",
                "socket_id": "socket_xyz",
                "prompt": "Create a todo list app with add, delete, and complete features",
                "context": None,
                "timestamp": "2025-12-16T10:00:00Z"
            }
        }


# ============================================================================
# ARCHITECTURE MODELS
# ============================================================================

class NavigationStructure(BaseModel):
    """App navigation configuration"""
    type: Literal["stack", "tab", "drawer"] = "stack"
    """Navigation pattern type"""
    
    routes: List[Dict[str, str]] = Field(default_factory=list)
    """Navigation routes between screens"""


class StateDefinition(BaseModel):
    """State management definition"""
    name: str
    """State variable name"""
    
    type: Literal["local-state", "global-state", "async-state"]
    """State type"""
    
    scope: Literal["component", "screen", "global"]
    """State scope"""
    
    initial_value: Any
    """Initial state value"""


class DataFlowDiagram(BaseModel):
    """Data flow representation"""
    user_interactions: List[str] = Field(default_factory=list)
    """List of user interaction types"""
    
    api_calls: List[str] = Field(default_factory=list)
    """List of API endpoints (if any)"""
    
    local_storage: List[str] = Field(default_factory=list)
    """Data stored locally"""


class ScreenDefinition(BaseModel):
    """Single screen definition"""
    id: str
    """Unique screen identifier"""
    
    name: str
    """Screen name (e.g., "Home", "Settings")"""
    
    purpose: str
    """Description of screen purpose"""
    
    components: List[str] = Field(default_factory=list)
    """List of component types needed"""
    
    navigation: List[str] = Field(default_factory=list)
    """Screens this screen can navigate to"""


class ArchitectureDesign(BaseModel):
    """
    Complete app architecture design.
    
    This is generated by the AI from the user's prompt.
    """
    app_type: Literal["single-page", "multi-page", "navigation-based"]
    """Type of app architecture"""
    
    screens: List[ScreenDefinition]
    """List of screens in the app"""
    
    navigation: NavigationStructure
    """Navigation configuration"""
    
    state_management: List[StateDefinition]
    """State management definitions"""
    
    data_flow: DataFlowDiagram
    """Data flow diagram"""
    
    class Config:
        json_schema_extra = {
            "example": {
                "app_type": "single-page",
                "screens": [
                    {
                        "id": "screen_1",
                        "name": "Todo List",
                        "purpose": "Main screen for managing todos",
                        "components": ["InputText", "Button", "Text"],
                        "navigation": []
                    }
                ],
                "navigation": {
                    "type": "stack",
                    "routes": []
                },
                "state_management": [
                    {
                        "name": "todos",
                        "type": "local-state",
                        "scope": "screen",
                        "initial_value": []
                    }
                ],
                "data_flow": {
                    "user_interactions": ["add_todo", "delete_todo"],
                    "api_calls": [],
                    "local_storage": ["todos_list"]
                }
            }
        }

# ============================================================================
# LAYOUT MODELS
# ============================================================================

class Position(BaseModel):
    """Component position on canvas"""
    x: int = Field(..., ge=0)
    """X coordinate (pixels from left)"""
    
    y: int = Field(..., ge=0)
    """Y coordinate (pixels from top)"""


class LayoutConstraints(BaseModel):
    """Component layout constraints"""
    width: str = "auto"
    """Width (e.g., "auto", "100%", "200px")"""
    
    height: int = Field(44, ge=0)
    """Height in pixels (min 44px for touch targets)"""
    
    margin_top: int = Field(0, ge=0)
    margin_bottom: int = Field(0, ge=0)
    margin_left: int = Field(0, ge=0)
    margin_right: int = Field(0, ge=0)
    
    padding: int = Field(0, ge=0)
    """Internal padding"""
    
    alignment: Literal["left", "center", "right", "stretch"] = "center"
    """Horizontal alignment"""


class ComponentDefinition(BaseModel):
    """
    Single UI component definition.
    
    Defines everything needed to render a component on the canvas.
    """
    id: str
    """Unique component identifier"""
    
    type: Literal[
        "Button", "InputText", "Switch", "Checkbox", "TextArea",
        "Slider", "Spinner", "Text", "Joystick", "ProgressBar",
        "DatePicker", "TimePicker", "ColorPicker", "Map", "Chart"
    ]
    """Component type (must be from available components)"""
    
    properties: Dict[str, Any]
    """Component-specific properties"""
    
    position: Position
    """Position on canvas"""
    
    constraints: LayoutConstraints
    """Layout constraints"""
    
    children: List['ComponentDefinition'] = Field(default_factory=list)
    """Child components (for containers)"""
    
    @field_validator('type')
    @classmethod
    def validate_component_type(cls, v: str) -> str:
        """Ensure component type is supported"""
        allowed = [
            "Button", "InputText", "Switch", "Checkbox", "TextArea",
            "Slider", "Spinner", "Text", "Joystick", "ProgressBar",
            "DatePicker", "TimePicker", "ColorPicker", "Map", "Chart"
        ]
        if v not in allowed:
            raise ValueError(f"Unsupported component type: {v}. Must be one of: {allowed}")
        return v
    
    class Config:
        json_schema_extra = {
            "example": {
                "id": "btn_1",
                "type": "Button",
                "properties": {
                    "label": "Add Todo",
                    "variant": "primary",
                    "size": "medium"
                },
                "position": {"x": 20, "y": 100},
                "constraints": {
                    "width": "90%",
                    "height": 44,
                    "marginTop": 20,
                    "alignment": "center"
                },
                "children": []
            }
        }


class LayoutDefinition(BaseModel):
    """
    Complete layout for a screen.
    
    Defines all components and their positions.
    """
    screen_id: str
    """Screen this layout belongs to"""
    
    layout_type: Literal["flex", "absolute", "grid"] = "flex"
    """Layout algorithm to use"""
    
    background_color: str = "#FFFFFF"
    """Background color (hex code)"""
    
    components: List[ComponentDefinition]
    """All components on this screen"""
    
    @field_validator('components')
    @classmethod
    def validate_no_duplicate_ids(cls, v: List[ComponentDefinition]) -> List[ComponentDefinition]:
        """Ensure all component IDs are unique"""
        ids = [comp.id for comp in v]
        if len(ids) != len(set(ids)):
            raise ValueError("Duplicate component IDs found in layout")
        return v
    
    @field_validator('background_color')
    @classmethod
    def validate_color(cls, v: str) -> str:
        """Ensure valid hex color"""
        if not v.startswith('#') or len(v) not in [4, 7]:
            raise ValueError(f"Invalid hex color: {v}. Must be #RGB or #RRGGBB")
        return v


# ============================================================================
# BLOCKLY MODELS
# ============================================================================

class BlockConnection(BaseModel):
    """Connection between Blockly blocks"""
    from_block: str
    """Source block ID"""
    
    to_block: str
    """Target block ID"""
    
    connection_type: Literal["next", "input", "output"]
    """Type of connection"""


class BlocklyDefinition(BaseModel):
    """
    Single Blockly block definition.
    
    Represents a visual programming block.
    """
    block_id: str
    """Unique block identifier"""
    
    type: Literal["event", "action", "getter", "setter", "logic", "math", "text"]
    """Block category"""
    
    block_json: Dict[str, Any]
    """Raw Blockly JSON (block-specific format)"""
    
    connections: List[BlockConnection] = Field(default_factory=list)
    """Connections to other blocks"""
    
    class Config:
        json_schema_extra = {
            "example": {
                "block_id": "event_1",
                "type": "event",
                "block_json": {
                    "type": "component_event",
                    "fields": {
                        "COMPONENT": "btn_add",
                        "EVENT": "onClick"
                    }
                },
                "connections": [
                    {
                        "from_block": "event_1",
                        "to_block": "action_1",
                        "connection_type": "next"
                    }
                ]
            }
        }
        # ============================================================================
# PROGRESS AND ERROR RESPONSES
# ============================================================================

class ProgressUpdate(BaseModel):
    """
    Progress update during AI processing.
    
    Sent to frontend for real-time progress tracking.
    """
    task_id: str
    """Task ID being processed"""
    
    socket_id: str
    """WebSocket ID"""
    
    type: Literal["progress"] = "progress"
    """Message type"""
    
    stage: str = Field(..., description="Current processing stage")
    """Current processing stage"""
    
    progress: int = Field(..., ge=0, le=100)
    """Progress percentage (0-100)"""
    
    message: str = ""
    """Progress message"""


class ErrorResponse(BaseModel):
    """
    Error response when something goes wrong.
    """
    task_id: str
    """Task ID that failed"""
    
    socket_id: str
    """WebSocket ID"""
    
    type: Literal["error"] = "error"
    """Message type"""
    
    error: str
    """Error message"""
    
    details: Optional[str] = None
    """Detailed error information"""


# ============================================================================
# TEST CODE (at the very end)
# ============================================================================

if __name__ == "__main__":
    # Test model creation
    print("\n" + "=" * 60)
    print("TESTING PYDANTIC MODELS")
    print("=" * 60)
    
    # Test AIRequest
    request = AIRequest(
        user_id="test_user",
        session_id="test_session",
        socket_id="test_socket",
        prompt="Create a simple counter app"
    )
    print(f"\n✅ AIRequest created: {request.task_id}")
    
    # Test ProgressUpdate
    progress = ProgressUpdate(
        task_id=request.task_id,
        socket_id=request.socket_id,
        stage="designing",
        progress=25,
        message="Creating architecture..."
    )
    print(f"✅ ProgressUpdate created: {progress.stage} - {progress.progress}%")
    
    # Test ErrorResponse
    error = ErrorResponse(
        task_id=request.task_id,
        socket_id=request.socket_id,
        error="Test error message"
    )
    print(f"✅ ErrorResponse created: {error.error}")
    
    print("\n" + "=" * 60)
    print("✅ All models validated successfully!")
    print("=" * 60 + "\n")